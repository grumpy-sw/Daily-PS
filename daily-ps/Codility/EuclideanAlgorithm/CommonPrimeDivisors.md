### Codility Lession 12(Euclidean algorithm) - CommonPrimeDivisors
ğŸ‘‰ [ë¬¸ì œ ë§í¬](https://app.codility.com/programmers/lessons/12-euclidean_algorithm/common_prime_divisors/)

### ë‚˜ì˜ ì ‘ê·¼ ë°©ë²•
- ì²˜ìŒì—ëŠ” ì—ë¼ìŠ¤í† í…Œë„¤ìŠ¤ì˜ ì²´ë¥¼ ì‚¬ìš©í•œ ì¸ìˆ˜ë¶„í•´ë¥¼ ê±°ì¹œ ë’¤ Setìœ¼ë¡œ ì¤‘ë³µì„ ì œê±°í•˜ì—¬ ë‘˜ì„ ë¹„êµí–ˆìœ¼ë‚˜ ëŸ°íƒ€ì„ ì—ëŸ¬ê°€ ë°œìƒí•˜ì—¬ ë‹¤ë¥¸ ë°©ë²•ì„ ê³ ë¯¼í–ˆë‹¤.
    - ì•„ë§ˆ ì •ìˆ˜ ë²”ìœ„ê°€ Int ë²”ìœ„ë¡œ ì£¼ì–´ì¡ŒëŠ”ë° ì¸ìˆ˜ë¶„í•´ë¥¼ ìœ„í•œ ë°°ì—´ì„ ë§Œë“¤ ë•Œ Array(repeating: 0, count: n+1)ë¡œ ë²”ìœ„ë¥¼ ì´ˆê³¼í–ˆê¸° ë•Œë¬¸ì¸ ê²ƒ ê°™ë‹¤.
- ë¬¸ì œ í•´ê²°ì˜ í•µì‹¬ ê°œë…ì€ ìµœëŒ€ê³µì•½ìˆ˜ì´ë‹¤. ë‘ ìˆ˜ Aì™€ Bì˜ ìµœëŒ€ê³µì•½ìˆ˜ë¥¼ Gë¼ê³  í•˜ë©´, Aì™€ Bë¥¼ ê°ê° Gë¡œ ë‚˜ëˆˆ ëª« ë˜í•œ Gì˜ ì•½ìˆ˜ë¼ë©´ ë‘˜ì€ ë™ì¼í•œ ì†Œì¸ìˆ˜ë¡œ ì´ë£¨ì–´ì§„ ìˆ˜ì´ë‹¤.
- ë°˜ëŒ€ë¡œ Aì™€ Bë¥¼ Gë¡œ ë‚˜ëˆˆ ëª«ì´ Gì˜ ì•½ìˆ˜ê°€ ì•„ë‹ˆë¼ë©´ ê·¸ ìˆ˜ë¥¼ êµ¬ì„±í•¨ì— ìˆì–´ ë‹¤ë¥¸ ì†Œì¸ìˆ˜ê°€ ê»´ìˆë‹¤ëŠ” ëœ»ì´ë¯€ë¡œ ë‘˜ì€ ê³µí†µì˜ ì†Œì¸ìˆ˜ë¡œ ì´ë£¨ì–´ì§„ ìˆ˜ê°€ ì•„ë‹ˆë‹¤.
- ë¨¼ì € Aì™€ Bë¡œ Gë¥¼ êµ¬í•œ ë’¤, Aì™€ Bë¥¼ Gì™€ì˜ ìµœëŒ€ê³µì•½ìˆ˜ë¥¼ êµ¬í•œë‹¤. ë‘ ìˆ˜ë¥¼ 1ì´ ë  ë•Œê¹Œì§€ ë‘˜ì˜ ìµœëŒ€ê³µë°°ìˆ˜ë¡œ ë‚˜ëˆ ì£¼ëŠ”ë°, ê·¸ ì „ì— Gê°€ 1ì´ ëœë‹¤ë©´ Aë‚˜ Bì—ëŠ” Gì— ì†í•˜ì§€ ì•Šì€ ë‹¤ë¥¸ ì†Œì¸ìˆ˜ê°€ ìˆë‹¤ëŠ” ëœ»ì´ë¯€ë¡œ falseë¥¼ ë°˜í™˜í•œë‹¤.
- Aì™€ Bê°€ ëª¨ë‘ 1ê¹Œì§€ ì¤„ì–´ë“¤ì—ˆë‹¤ë©´ ë‘˜ì€ ê°™ì€ ì†Œì¸ìˆ˜ë¡œ ì´ë£¨ì–´ì§„ ìˆ˜ì´ë¯€ë¡œ trueë¥¼ ë°˜í™˜í•˜ê³  resultë¥¼ 1 ì¦ê°€ì‹œí‚¨ë‹¤.
- ì´ ì•Œê³ ë¦¬ì¦˜ì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(Z * log(max(A) + max(B))**2)ì´ë‹¤.

### ì½”ë“œ(Swift)
```swift
public func solution(_ A : inout [Int], _ B : inout [Int]) -> Int {
    var result = 0
    let N = A.count
        
    for index in 0..<N {
        let a = A[index]
        let b = B[index]
            
        if samePrimeDiv(a, b) {
            result += 1
        }   
    }
        
    return result
}
    
func gcd(_ a: Int, _ b: Int) -> Int {
    if b == 0 {
        return a
    }
    return (a % b == 0) ? b : gcd(b, a % b)
}
    
func samePrimeDiv(_ a: Int, _ b: Int) -> Bool {
    var a = a
    var b = b
    let g = gcd(a, b)
        
    var c = g
    while a > 1 {
        c = gcd(a, c)
            
        if c == 1 {
            return false
        }
        a /= c
    }
        
    c = g
        
    while b > 1 {
        c = gcd(b, c)
            
        if c == 1 {
            return false
        }
        b /= c
    }
        
    return true
}
```
